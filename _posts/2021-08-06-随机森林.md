---
title: 随机森林
date: 2021-08-06 15:47:18
description: learned in summer vacation
comments: true
categories:
- learning-notes
tags:
- machine-learning
---





# 随机森林

## 1定义

随机森林是一种由决策树构成的集成算法

### 1.1 四个概念

- 基本概念
- 4个构造步骤
- 4种方式对比测评
- 10个优缺点，4个应用方向

#### 1.1.1基本概念

随机森林属于 集成学习 中的 Bagging（Bootstrap AGgregation 的简称） 方法

<img src="https://easy-ai.oss-cn-shanghai.aliyuncs.com/2019-08-21-weizhi.png" alt="随机森林属于集成学习中的Bagging方法" style="zoom: 33%;" />

#### 1.1.2决策树

<img src="https://easy-ai.oss-cn-shanghai.aliyuncs.com/2019-08-21-decision-tree.png" alt="图解决策树" style="zoom:33%;" />

决策树是一种逻辑简单的机器学习算法，它是一种树形结构，所以叫决策树

**元素构成**

- 根节点：包含样本的全集
- 内部节点：对应特征属性测试
- 叶节点：代表决策的结果

预测时，在树的内部节点处用某一属性值进行判断，根据判断结果决定进入哪个分支节点，直到到达叶节点处，得到分类结果。

这是一种基于 if-then-else 规则的有监督学习算法，决策树的这些规则通过训练得到，而不是人工制定的。

决策树是最简单的机器学习算法，它易于实现，可解释性强，完全符合人类的直观思维，有着广泛的应用。

#### 1.1.3决策树优缺点

**优点**

- 决策树易于理解和解释，可以可视化分析，容易提取出规则；
- 可以同时处理标称型和数值型数据；
- 比较适合处理有缺失属性的样本；
- 能够处理不相关的特征；
- 测试数据集时，运行速度比较快；
- 在相对短的时间内能够对大型数据源做出可行且效果良好的结果。

**缺点**

- 容易发生过拟合（随机森林可以很大程度上减少过拟合）；
- 容易忽略数据集中属性的相互关联；
- 对于那些各类别样本数量不一致的数据，在决策树中，进行属性划分时，不同的判定准则会带来不同的属性选择倾向；信息增益准则对可取数目较多的属性有所偏好（典型代表ID3算法），而增益率准则（CART）则对可取数目较少的属性有所偏好，但CART进行属性划分时候不再简单地直接利用增益率尽心划分，而是采用一种启发式规则）（只要是使用了信息增益，都有这个缺点，如RF）。
- ID3算法计算信息增益时结果偏向数值比较多的特征。

### 1.2构造步骤

<img src="https://easy-ai.oss-cn-shanghai.aliyuncs.com/2019-08-21-4steps.png" alt="构造随机森林的4个步骤" style="zoom:33%;" />

1. 一个样本容量为N的样本，有放回的抽取N次，每次抽取1个，最终形成了N个样本。这选择好了的N个样本用来训练一个决策树，作为决策树根节点处的样本。
2. 当每个样本有M个属性时，在决策树的每个节点需要分裂时，随机从这M个属性中选取出m个属性，满足条件m << M。然后从这m个属性中采用某种策略（比如说信息增益）来选择1个属性作为该节点的分裂属性。
3. 决策树形成过程中每个节点都要按照步骤2来分裂（很容易理解，如果下一次该节点选出来的那一个属性是刚刚其父节点分裂时用过的属性，则该节点已经达到了叶子节点，无须继续分裂了）。一直到不能够再分裂为止。注意整个决策树形成过程中没有进行剪枝。
4. 按照步骤1~3建立大量的决策树，这样就构成了随机森林了。

### 1.3优缺点

**优点**

1. 它可以出来很高维度（特征很多）的数据，并且不用降维，无需做特征选择
2. 它可以判断特征的重要程度
3. 可以判断出不同特征之间的相互影响
4. 不容易过拟合
5. 训练速度比较快，容易做成并行方法
6. 实现起来比较简单
7. 对于不平衡的数据集来说，它可以平衡误差。
8. 如果有很大一部分的特征遗失，仍可以维持准确度。

**缺点**

1. 随机森林已经被证明在某些噪音较大的分类或回归问题上会过拟合。
2. 对于有不同取值的属性的数据，取值划分较多的属性会对随机森林产生更大的影响，所以随机森林在这种数据上产出的属性权值是不可信的

### 1.4应用对象

<img src="https://easy-ai.oss-cn-shanghai.aliyuncs.com/2019-08-21-application.png" alt="随机森林的 4 个应用方向" style="zoom:33%;" />

### 1.5Code

#### 1.5.1 nni调优

```python
#---------------------------------nni--------------------------------------
LOG = logging.getLogger('test_LSTM')

#TENSORBOARD_DIR = os.environ['NNI_OUTPUT_DIR']

class Logger(object):# 日志类
    def __init__(self, file_name="Default.log", stream=sys.stdout):
        self.terminal = stream
        self.log = open(file_name, "a")

    def write(self, message):
        self.terminal.write(message)
        self.log.write(message)

    def flush(self):
        pass
    
#nni中返回中间值调用，在api和sequential类型的模型中可以调用，大多数分类器没有相关argument
class SendMetrics(keras.callbacks.Callback): 
    
    '''
    Keras callback to send metrics to NNI framework
    '''
    def on_epoch_end(self, epoch, logs={}):
        '''
        Run on end of each epoch
        '''
        logging.debug(logs)
        nni.report_intermediate_result(logs["val_acc"])

        

try: 
    tuner_params = nni.get_next_parameter()
    LOG.debug(tuner_params)

    params = {
        'n_estimators': 11,
        'min_samples_leaf': 2,
        'min_samples_split': 2,
        'max_features': 11 
    }

    params.update(tuner_params)
    # 实验参数设置
    min_samples_leaf = params['min_samples_leaf'] # 不必要超过8及以上
    min_samples_split = params['min_samples_split'] # 不必要超过8及以上
    max_features = params['max_features'] # 50往上的效果可能较好
    n_estimators = params['n_estimators'] # 有待商榷，40、28、8可以出效果比较好的结果
    #------------------------------------nni----------------------------------------
    # ps：以上调参针对50000*70*4的特征集和16分类的标签
```

#### 1.5.2 代码实现

```python
def RandomTree(X_train, X_test, Y_train, Y_test):
        from sklearn.ensemble import RandomForestClassifier # 引入随机森林包
        model = RandomForestClassifier(n_estimators=n_estimators, min_samples_leaf=min_samples_leaf, min_samples_split=min_samples_split, max_features=max_features)# 调整参数
        # # ------------------------fit network--------------------------------
        X_train = ma.masked_values(X_train, -10)
        # Y_train = ma.masked_values(Y_train, -10)
        X_test = ma.masked_values(X_test, -10)
        # Y_test = ma.masked_values(Y_test, -10)
        #early_stopping = EarlyStopping( monitor='val_acc', min_delta=0.025, patience=25, verbose=1, mode='max')
        X_train = np.reshape(X_train, (X_train.shape[0], X_train.shape[1]*X_train.shape[2]))
        X_test = np.reshape(X_test,(X_test.shape[0], X_test.shape[1]*X_test.shape[2]))      
        history = model.fit(X_train, Y_train)
        # # ------------------------fit network-------------------------------- 
        # # -------------------------evaluate--------------------------------
        score = np.mean(cross_val_score(model,X_test,Y_test))
        pred = model.predict(X_test)
        
        cm = confusion_matrix(Y_test.argmax(axis=1), pred.argmax(axis=1))
        cm = cm.astype(np.float)
        u = plot_confusion_matrix(cm, 'ABCDEFGHIJKLMNOP', title='confusion matrix')
        return score, model, history
        ## nni报告最终值
        LOG.debug('score: %s' % score)
        nni.report_final_result(score)

except Exception as e:
    LOG.exception(e)
    raise
```

### 1.6参数解释

#### **n_estimators:**

对原始数据集进行有放回抽样生成的子数据集个数，即决策树的个数。若n_estimators太小容易欠拟合，太大不能显著的提升模型，所以n_estimators选择适中的数值，版本0.20的默认值是10,版本0.22的默认值是100。

#### **bootstrap:**

是否对样本集进行有放回抽样来构建树，True表示是,默认值True。

#### oob_score:

是否采用袋外样本来评估模型的好坏，True代表是，默认值False,袋外样本误差是测试数据集误差的无偏估计，所以推荐设置True。

<u>RF框架的参数很少，框架参数择优一般是调节n_estimators值，即决策树个数。</u>

#### **max_features:**

构建决策树最优模型时考虑的最大特征数。默认是"auto"，表示最大特征数是N的平方根;“log2"表示最大特征数是 ![[公式]](https://www.zhihu.com/equation?tex=log_%7B2%7DN) ;"sqrt"表示最大特征数是 ![[公式]](https://www.zhihu.com/equation?tex=%5Csqrt%7BN%7D) 。如果是整数，代表考虑的最大特征数；如果是浮点数，表示对(N * max_features)取整。其中N表示样本的特征数。

#### **max_depth:**

决策树最大深度。若等于None,表示决策树在构建最优模型的时候不会限制子树的深度。如果模型样本量多，特征也多的情况下，推荐限制最大深度；若样本量少或者特征少，则不限制最大深度。

#### **min_samples_leaf:**

叶子节点含有的最少样本。若叶子节点样本数小于min_samples_leaf，则对该叶子节点和兄弟叶子节点进行剪枝，只留下该叶子节点的父节点。整数型表示个数，浮点型表示取大于等于（样本数 * min_samples_leaf)的最小整数。min_samples_leaf默认值是1。

#### **min_samples_split:**

节点可分的最小样本数，默认值是2。整数型和浮点型的含义与min_samples_leaf类似。

#### **max_leaf_nodes:**

最大叶子节点数。int设置节点数,None表示对叶子节点数没有限制。

#### **min_impurity_decrease:**

节点划分的最小不纯度。假设不纯度用信息增益表示，若某节点划分时的信息增益大于等于min_impurity_decrease，那么该节点还可以再划分；反之，则不能划分。

#### **criterion:**

表示节点的划分标准。不纯度标准参考Gini指数，信息增益标准参考"entrop"熵。

#### **min_samples_leaf:**

叶子节点最小的样本权重和。叶子节点如果小于这个值，则会和兄弟节点一起被剪枝，只保留叶子节点的父节点。默认是0，则不考虑样本权重问题。一般来说，如果有较多样本的缺失值或偏差很大，则尝试设置该参数值。
